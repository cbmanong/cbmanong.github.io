<!DOCTYPE html>
<html>

<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="" />

<link rel="shortcut icon" href="">


<title> 对Redis的深入了解</title>


<link rel="stylesheet" href="/css/bulma.css">
<link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/base.css">

<body>

  <style media="screen">
hr {
  height: 1px;
    background-color: black;
    margin-top: 0px;
    border: none;
    margin-bottom: 0px;
}
.black {


background-color: hsl(0,0%,7%);;


}
 #shadow {
  text-shadow: 2px 3px 3px white;
  margin-top: 3px;
}
h1 {
  text-shadow: 2px 3px 3px black;
 }
.menu {
margin-top: -80px;




}
#nav {
  margin-left: 2px;
  margin-right: 2px;
}
  #banner {
    position: relative;

  }
</style>
<header>
	
  <section class="section black is-medium" id="banner">
  <img src="http://orulqrhz4.bkt.clouddn.com/blog/180218/2FmfJ0mae6.jpg?imageslim" />
    <div class="container">
      <h1 id="sitetitle" class="title is-3 has-text-white-bis has-text-centered is-capitalized has-text-weight-bold">
        
        yigexiaomanong
      </h1>

      <h2 id="shadow" class="subtitle is-4 has-text-white is-capitalized has-text-centered">

      </h2>

    </div>

    </div>
  </section>
<!--TOP Menu-->
  <div class="menu level" >
<div class="level-item has-text-centered"></div>
    <nav class=".navbar level-item" >
      
        <a style="text-shadow: 2px 2px 3px grey" id="nav" class="button is-text is-outlined is-primary " href="


            /
            "> Home</a>
        
        <a style="text-shadow: 2px 2px 3px grey" id="nav" class="button is-text is-outlined is-primary " href="


            mailto:cbmnanqing@163.com
            "> Email</a>
        
        <a style="text-shadow: 2px 2px 3px grey" id="nav" class="button is-text is-outlined is-primary " href="


            https://github.com/cbmanong/
            "> Project</a>
        
        <a style="text-shadow: 2px 2px 3px grey" id="nav" class="button is-text is-outlined is-primary " href="


            /archives
            "> Archive</a>
        
    </nav>
    <div class="level-item has-text-centered"></div>
</div>

  <hr>






</header>



<link rel="stylesheet" href="/css/highlight.css">
<style>
    .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 960px;
        margin: 0 auto;
        padding: 45px;
    }

    @media (max-width: 767px) {
        .markdown-body {
            padding: 15px;
        }
    }
    #postsec {
        clear: left;
    }



    .details {
        float: left;
        padding-left: 10px;
        font-size: 18px;

    }
    div > span {
       margin-left: 0px;
      margin-top: 0px;
    }
</style>
<section id="post_section" class="container markdown-body" >

    <!--title,date,tags-->
    <h2 id="hidden">
        对Redis的深入了解
    </h2>

    <section class="desec">

        
    </section>


    <!-- content -->
    <section id="postsec"><h3 id="1-Redis的持久化"><a href="#1-Redis的持久化" class="headerlink" title="1.Redis的持久化"></a>1.Redis的持久化</h3><blockquote>
<p>持久化就是将数据保存到磁盘中，就算机器宕机或重启数据都不会丢失，而存储到内存中的数据就会丢失。而redis的强大很大程度上是由于其将所有数据存储到内存中，为了使redis在重启后仍能保证数据不丢失，需要将数据从内存中以某种形式持久化到硬盘中，redis支持两种方式的持久化，一种是RDB，另一种是AOF，可以单独使用一种或结合两种使用。</p>
</blockquote>
<a id="more"></a>
<h3 id="2-RDB-redis的默认持久化方式"><a href="#2-RDB-redis的默认持久化方式" class="headerlink" title="2. RDB(redis的默认持久化方式)"></a>2. RDB(redis的默认持久化方式)</h3><blockquote>
<p>RDB方式是通过快照完成的，(快照的核心原理就是把redis在某个时间<em>内存中 的所有数据</em>都写入硬盘)当符合一定条件时redis会自动将内存中的所有数据进行快照并且存储到硬盘上(默认在主目录生成一个dump.rbp文件，用二进制压缩存储，所以出现乱码)。而进行快照的条件在配置文件redis.windows.conf中指定，主要由2个参数构成：时间和改动的键的个数，当在指定时间内被更改的键的个数大于指定数值时就会进行快照。</p>
</blockquote>
<p><img src="http://orulqrhz4.bkt.clouddn.com/blog/180121/8FgdDi8aH6.png?imageslim" alt="mark"></p>
<p><img src="http://orulqrhz4.bkt.clouddn.com/blog/180121/gbg15KAhk8.png?imageslim" alt="mark"></p>
<h4 id="2-1创建RDB快照"><a href="#2-1创建RDB快照" class="headerlink" title="2.1创建RDB快照"></a>2.1创建RDB快照</h4><h4 id="2-1-1-快照的过程"><a href="#2-1-1-快照的过程" class="headerlink" title="2.1.1 快照的过程"></a>2.1.1 快照的过程</h4><p>1)redis使用fork函数复制一份当前进程(父进程)的副本(子进程)；</p>
<p>2)父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入到硬盘中的临时文件；</p>
<p>3)当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，rdb文件通过二进制压缩，所以才出现下情况。不过我们可以通过配置rdbcompression参数来禁用压缩！</p>
<p><img src="http://orulqrhz4.bkt.clouddn.com/blog/180121/dF3FkcJJLF.png?imageslim" alt="mark"></p>
<p><img src="http://orulqrhz4.bkt.clouddn.com/blog/180121/ja4Lf27ek1.png?imageslim" alt="mark"></p>
<blockquote>
<p>综上可知rdb方式数据持久化效率低，而且大文件时占用很大内存，就会给其他程序造成影响！</p>
</blockquote>
<h4 id="2-1-2-手动快照"><a href="#2-1-2-手动快照" class="headerlink" title="2.1.2 手动快照"></a>2.1.2 手动快照</h4><blockquote>
<p>如果没有满足条件就不会触发自动快照，实际业务中我们不知道到底有没有触发但又要对redis进行重启，重启就会造成数据丢失，所以此时需要对redis进行手动快照操作，进行数据持久化。而save和bgsave命令都可以进行手动快照，但区别很大：</p>
<blockquote>
<p>save命令是由主进程进行快照，会阻塞其他请求，而bgsave是通过fork子进程进行快照操作。推荐使用save命令！</p>
</blockquote>
<p><img src="http://orulqrhz4.bkt.clouddn.com/blog/180121/Af50e1lHHK.png?imageslim" alt="mark"></p>
<p>在redis的高级版本中，一旦服务重启，会自动做rdb！</p>
</blockquote>
<h4 id="2-1-3-快照注意点"><a href="#2-1-3-快照注意点" class="headerlink" title="2.1.3 快照注意点"></a>2.1.3 快照注意点</h4><blockquote>
<p>由于redis使用form来复制一份当前进程，那么子进程就会占有和主线程一样的内存资源，比如说主进程占8G内存，那么子进程也要8G，做备份的时候就必须保证有16G的内存，如果没有就会造成内存溢出，此时就会启用虚拟内存，就是在硬盘中划分一小块拿来代替内使用，我们知道硬盘的读写速度远不及内存的读写速度，所以此时性能非常差！</p>
</blockquote>
<h4 id="2-1-4RDB文件的压缩"><a href="#2-1-4RDB文件的压缩" class="headerlink" title="2.1.4RDB文件的压缩"></a>2.1.4RDB文件的压缩</h4><blockquote>
<p>RDB文件默认是会进行压缩的</p>
</blockquote>
<p>压缩与不压缩的区别：</p>
<p>压缩：</p>
<ul>
<li>优点：减少磁盘存储空间</li>
<li>缺点：消耗CPU资源</li>
</ul>
<p>不压缩：</p>
<ul>
<li>优点：不消耗CPU资源</li>
<li>缺点：占用磁盘空间多</li>
</ul>
<p>如何选择？</p>
<blockquote>
<p>看服务器的资源情况，解压缩是非常消耗cpu资源的，一般我们为了节约cpu资源是采取不压缩的方式。</p>
</blockquote>
<h4 id="2-1-5-RDB快照的恢复"><a href="#2-1-5-RDB快照的恢复" class="headerlink" title="2.1.5 RDB快照的恢复"></a>2.1.5 RDB快照的恢复</h4><blockquote>
<p>redis启动后底层会自动读取rdb快照文件，将数据从硬盘载入到内存中，一般情况下1GB的快照文件载入到内存中的时间约为20~30秒钟，不过不同服务器会有差异！</p>
</blockquote>
<h4 id="2-1-6-如何关闭持久化？"><a href="#2-1-6-如何关闭持久化？" class="headerlink" title="2.1.6 如何关闭持久化？"></a>2.1.6 如何关闭持久化？</h4><blockquote>
<p>我们知道rdb持久化原因就是当在指定时间内被更改的键的个数大于指定数值时就会进行快照。所以我们只要设置条件不满足即可，如果没有条件俺么就永远不会进行rdb持久化！</p>
</blockquote>
<h3 id="3-AOF"><a href="#3-AOF" class="headerlink" title="3.AOF"></a>3.AOF</h3><blockquote>
<p>AOF和RDB是可以共存的，默认情况下只开启了RDB，所以我们可以通过修改配置文件的appendonly参数来开启ROF持久化</p>
</blockquote>
<p><img src="http://orulqrhz4.bkt.clouddn.com/blog/180121/FE3HbDI1ae.png?imageslim" alt="mark"></p>
<h4 id="3-1-AOF的工作方式"><a href="#3-1-AOF的工作方式" class="headerlink" title="3.1 AOF的工作方式"></a>3.1 AOF的工作方式</h4><p>测试：</p>
<blockquote>
<p>当客户端向服务器发送redis命令时，redi会将执行的命令记录到aof文件中，当redis服务器重启后，会执行该aof文件，达到数据恢复的目的。</p>
</blockquote>
<p><img src="http://orulqrhz4.bkt.clouddn.com/blog/180121/3HHGCg0lIk.png?imageslim" alt="mark"></p>
<blockquote>
<p>所以redis的aof持久化策略是将发送到redis服务端的<code>每一条命令都记录下来</code>，而不是记录数据，并且保存到硬盘中的aof文件中，aof文件的位置和rdb的文件位置相同，都是通过dir参数设置。</p>
</blockquote>
<p>与rdb相比：因为aof是记录命令，所以效率快；另一方面，aof记录命令数据量大！ </p>
<h4 id="3-2AOF文件的重写-保留最终数据命令"><a href="#3-2AOF文件的重写-保留最终数据命令" class="headerlink" title="3.2AOF文件的重写(保留最终数据命令)"></a>3.2AOF文件的重写(保留最终数据命令)</h4><blockquote>
<p>之前我们对age进行了两次操作，都会记录在aof文件中，但对于一个变量的多次操作，只需要记录最后一次操作即可，所以aof机制会自动对aof文件进行优化，当文件过大时，就会把文件中多余命令移除，即<code>对同一个key的重复操作</code>,从而保证文件体积。而aof文件的自动重写规则可以在配置文件进行设置</p>
<p><img src="http://orulqrhz4.bkt.clouddn.com/blog/180121/m644Kiahi3.png?imageslim" alt="mark"></p>
</blockquote>
<p>注：我们也可以手动进行优化，即使用BGREWRITEAOF命令来重写AOF文件</p>
<h4 id="3-3-文件同步策略"><a href="#3-3-文件同步策略" class="headerlink" title="3.3 文件同步策略"></a>3.3 文件同步策略</h4><blockquote>
<p>注意：即使每秒做文件同步也可能导致数据丢失</p>
</blockquote>
<p><img src="http://orulqrhz4.bkt.clouddn.com/blog/180121/IfLFbCl3F6.png?imageslim" alt="mark"></p>
<h3 id="4-redis的主从复制"><a href="#4-redis的主从复制" class="headerlink" title="4. redis的主从复制"></a>4. redis的主从复制</h3><blockquote>
<p>目的就是数据备份，防止数据丢失</p>
</blockquote>
<p>好处：</p>
<ul>
<li>避免redis单点故障</li>
<li>构建读写分离，满足读多写少的应用场景</li>
</ul>
<p>1)主从架构：<br><img src="http://orulqrhz4.bkt.clouddn.com/blog/180121/jdH9Eh6Dc5.png?imageslim" alt="mark"></p>
<p>设置主从的两种方式：</p>
<ul>
<li><p>在redis.conf中设置slaveof,永久的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用redis-cli客户端连接到redis服务，执行slaveof命令,不过在重启后将失去主从复制关系</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof&lt;masterip&gt;&lt;masterport&gt;</span><br></pre></td></tr></table></figure>
<p>2)主从从架构</p>
<p><img src="http://orulqrhz4.bkt.clouddn.com/blog/180121/Ai1ed5CJ6J.png?imageslim" alt="mark"></p>
<h4 id="4-1-redis的主从复制原理-有磁盘"><a href="#4-1-redis的主从复制原理-有磁盘" class="headerlink" title="4.1 redis的主从复制原理(有磁盘)"></a>4.1 redis的主从复制原理(有磁盘)</h4><p>1)当主库和从库建立MS关系后，从库会向主数据库发送PSYNC命令(即同步命令);</p>
<p>2)主库接收到PSYNC命令后会开始在后台保存快照(RDB持久化过程,此时保存的是以前的数据),并将期间接收到的写命令缓存起来(保存的是最新的数据);</p>
<p>3)当快照完成后，主redis会将快照文件和所有缓存命令(两者加起来就是完整的数据)发送给从redis；</p>
<p>4)从redis接收到后，会载入快照文件并且执行收到的缓存的命令;</p>
<p>5)之后，主redis每当接收到<code>写命令</code>时就会将命令发送给从redis，从而保证数据的一致</p>
<blockquote>
<p>所以一旦涉及到集群，就无需设置rdb和aof</p>
</blockquote>
<h4 id="4-2-redis的无磁盘复制原理"><a href="#4-2-redis的无磁盘复制原理" class="headerlink" title="4.2 redis的无磁盘复制原理"></a>4.2 redis的无磁盘复制原理</h4><blockquote>
<p>通过前面的复制过程我们了解到，主库收到PSYNC命令时会执行RDB过程，即时在配置文件中禁用RDB持久化也会生成，那么如果主库所在的服务器磁盘IO性能差，那么这个复制过程就会出现瓶颈。庆幸的是，redis在2.8.18版本开始实现了无磁盘复制功能(不过该功能还是处于实验阶段)。</p>
</blockquote>
<p>原理：redis在与从数据库进行复制初始化时将不会将快照存储到磁盘中，而是直接通过网络发送给从数据库，避免了IO性能差的问题</p>
<p>开启无磁盘复制：repl-diskless-sync yes</p>
<h4 id="4-3-复制架构中出现宕机情况，如何处理？"><a href="#4-3-复制架构中出现宕机情况，如何处理？" class="headerlink" title="4.3 复制架构中出现宕机情况，如何处理？"></a>4.3 复制架构中出现宕机情况，如何处理？</h4><p>如果在主从复制架构中出现宕机的情况，需要分情况处理：</p>
<p>1)从Redis宕机</p>
<ul>
<li>这个相对而言比较简单，在redis中从库重新启动后会自动加入到主从架构中，自动完成同步数据；</li>
<li>但是存在问题，如果从库在断开期间，主库的变化不大时，从库再次启动后，主库依然会将所有的数据做rdb操作吗？还是增量更新？(注意从库有做持久化的前提下)</li>
</ul>
<blockquote>
<p>答案显然不会，因为redis在2.8版本后就实现了主从断线后恢复的情况下实现增量复制。</p>
</blockquote>
<p>2)主redis宕机</p>
<p>较之前者相对复杂一些，需要以下2步才能完成</p>
<p>第一步：在从数据库中执行SLAVEOF NO ONE 命令，断开主从关系并且提升为主库继续服务；</p>
<p>第二步：将主库重新启动后，执行SLAVEOF 命令，将其设置为其他库的从库，这时数据就能更新回来</p>
<blockquote>
<p>不过这个手动完成恢复的过程比较麻烦而且容易出错，所有redis提供的哨兵(sentinel)功能就能解决这一问题。</p>
</blockquote>
<p>附：mysql的读写分离实现过程</p>
<p>1)master将相应改变到二进制日志(binary log)中，这些记录叫做二进制事件，binary log events</p>
<p>2)slave将master中的binary log events拷贝到它的中继日志relay log</p>
<p>3)slave 重做中继日志中的事件，将改变反应到自己的数据中</p>
<p><img src="http://orulqrhz4.bkt.clouddn.com/blog/180121/5CFhJbD4JJ.png?imageslim" alt="mark"></p>
<h3 id="5-哨兵-sentinel"><a href="#5-哨兵-sentinel" class="headerlink" title="5.哨兵(sentinel)"></a>5.哨兵(sentinel)</h3><p>什么是哨兵？</p>
<blockquote>
<p>哨兵的作用就是对redis的系统的运行情况进行了监控，它是一个独立的进程，功能主要有以下两个：<br>1)监控主数据库和从数据库是否运行正常;</p>
<p><em>2)主数据出现故障后自动将从数据库转化为主数据库。</em></p>
</blockquote>
<p>原理：</p>
<p>单个哨兵的架构</p>
<p><img src="http://orulqrhz4.bkt.clouddn.com/blog/180121/eKdjlAL26J.png?imageslim" alt="mark"></p>
<p>多个哨兵的架构</p>
<p><img src="http://orulqrhz4.bkt.clouddn.com/blog/180121/fdE4BkBhba.png?imageslim" alt="mark"></p>
<blockquote>
<p>注意：多个哨兵不仅同时监控主从数据库，而且哨兵之间互为监控！</p>
</blockquote>
<h3 id="6-Redis的分布式连接-分片集群"><a href="#6-Redis的分布式连接-分片集群" class="headerlink" title="6.Redis的分布式连接(分片集群)"></a>6.Redis的分布式连接(分片集群)</h3><p>什么是分片?(shard)</p>
<blockquote>
<p>分片就是分布式存储，就是把原来存储到一个redis服务的数据，拆分存储到多个redis服务中，称为分片。</p>
</blockquote>
<p>为什么要分片？</p>
<blockquote>
<p>因为单台redis服务所能存储的数据容量、单核cpu的运算能力是有上限的，为了支持更大数据量的存储，更高的并发运算能力。实际业务中我们需要对数据进行拆分，分别存储到不同的redis服务节点。数据进行了拆分，用户的请求也进行了分流。</p>
</blockquote>
<p>注意：在redis3.0之前的版本中，服务端是不支持分片的，仅仅支持简单的主从配置，读写分离，为了实现数据的分片存储，我们只能通过客户端来实现，也就是使用Jedis；Redis3.0版本的一大特性就是集群。当我们启动多台redis服务时，redis之间本身是没有联系的，只是我们在存储数据时，jedis会根据某种算法把不同的key存储到不同的redis节点上，这样每个节点都有一部分数据，查询是也是类似的方式，从而实现了redis的分片。</p>
<p><img src="http://orulqrhz4.bkt.clouddn.com/blog/180121/bbLFHJ8ic3.png?imageslim" alt="mark"></p>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><img src="http://orulqrhz4.bkt.clouddn.com/blog/180121/8egf0GJAdg.png?imageslim" alt="mark"></p>
<p>(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.</p>
<p>(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.</p>
<p>(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可</p>
<p>(4)redis-cluster把所有的物理节点映射到[0-16383]slot（插槽）上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value</p>

    </section>


</section>
<script>var title = document.getElementById("hidden");
    title.style.display = "none";
    sitetitle = document.getElementById("sitetitle");
    titlev = title.childNodes[0].nodeValue;
    sitetitle.innerHTML = titlev;
    shadow = document.getElementById("shadow");
    shadow.style.visibility = "hidden";
</script>
<!-- 评论系统-->





<style>
    #height {
        height: 100px;
        box-sizing: border-box;
        color: rgb(51, 51, 51);
        font-size: 18px;
        font-weight: 400;

    }

    .footer_p {
        box-sizing: border-box;
        font-size: 18px;
        font-weight: 200;
        line-height: 27px;
        text-align: center;
        text-rendering: optimizelegibility;
    }

    .footer_link {
        color: black;
    }
</style>
<footer class="footer" id="height">

    <div class="container">
        <div class="content has-text-centered ">
            <p class="footer_p">
                Theme By<a href="https://github.com/cbmanong/" class="footer_link
"> Cbmn.</a>
            
               
               
            </p>
        </div>
        <div class="content has-text-centered">
            <p class="footer_p">Powered By <a href="https://hexo.io/" class="footer_link
"> Hexo.</a></p>
        </div>
    </div>

</footer>

<script src="/js/jquery.js"></script>

<!-- 特效 -->
<script type="text/javascript" color="#555" opacity='0.9' zIndex="-1" count="100"
src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">

</script>
<script src="/js/highlight.pack.js"></script>
<script>
    document.addEventListener("DOMContentLoaded", function(event) {
        var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
        codeBlocks.forEach(function(block, index) {
            hljs.highlightBlock(block);
        });
    });
</script>

</body>
